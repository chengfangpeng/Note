


## Java内存区域

#### 运行时数据区域

1. 程序计数器（线程私有）

是一块比较小的内存区域，它的作用可以看作是当前线程执行的字节码的行号指示器，该区域是唯一一块在虚拟机规范中不会抛出OutOfMemoryError的区域。

2. Java虚拟机栈（线程私有）

存储的是Java中的局部变量部分，线程中方法的调用对应着虚拟机中栈帧入栈出栈的过程。如果线程请求栈的深度大于虚拟机设置的栈的深度，会抛出StackOverFlowError,无法再分配内存时，会抛出OutOfMemoryError.

3. 本地方法栈

和虚拟机栈类似，只不过一个是一个对应的是Java方法，一个对应的是Native方法。

4. Java堆

它是所有线程共享的一块内存区域，存放对象实例，它是GC的主要区域。
分带收集算法：新生代、老年代

5. 方法区

线程共享的内存，用于存放已被虚拟机加载的类的信息，常量，静态变量等。

6. 运行时常量池

7. 直接内存

使用Natvie函数直接分配的堆外内存。在设置-Xmx时需要考虑直接内存，否则在堆内存动态扩展是，会出现OutOfMemoryError.


#### 对象访问

主流访问对象的方式有两种：

1. 句柄方式
reference中存放的是句柄的地址，句柄中包含实例数据地址和类型数据地址。

2. 直接指针
refercence中存放的就是对象的地址，而对象中包含了类型数据的地址。


#### OutOfMemoryError


## 对象已死

####  引用计数算法

给对象中添加一个引用计数器，当有一个地方引用它时，计数器加1，当引用失效时，计数器减1, 当计数器为0时则对象没有在被引用。但是它有个缺点不能很好的处理相互循环引用的问题，就是两个对象已经没有被外界所引用了，但是由于他们之间相互引用导致，计时器不为0.



#### 根搜索算法

当一个对象到Gc Roots没有引用链可达时，证明该对象是不可用的，可以被回收。
可以作为Gc Roots对象的包括：

1. 虚拟机栈中引用的对象
2. 方法区中的类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中的JNI引用的对象


## 引用类型

1. 强引用（Strong Reference）
通过new生产的对象，垃圾回收即使触发oom也不会回收的对象

2. 软引用 (Soft Reference)
当内存不足时，gc时才会回收的对象。

3. 弱引用 (Weak Reference)
每次gc时，都会被回收的对象

4. 虚引用
对该引用的生存时间不会造成任何的影响，只是希望在垃圾回收器回收该对象时，接受到一个系统的通知。


## 生存还是死亡

根据可达性算法不可达的对象并不是非死不可，它只是处于缓刑阶段，需要经历两次标记才能正式被回收。
第一次标记 -> 判断是否需要执行finallize()方法 -> 第二次标记 -> 对象被回收

在finallize方法中，可以让对象起死回生，方法是重新被引用。


## 垃圾收集算法


#### 标记-清除算法

顾名思义就是先标记，然后清除，但是这种算法有两个缺点：

1. 效率不高
2. 会产生很多的内存碎片。

#### 复制算法

将内存等分为两块，当第一块内存满了，就将存活的对象复制到第二块内存中。然后把第一块内存整体回收。这种方案有个缺点就是会浪费一半的内存空间。据统计新生代中的对象98%是朝生夕死的，没必要按照1:1的比例划分。新的划分方法是：Eden + 2块Survivor， Eden和Survivor大小比例是8:1, 当回收时，将Eden和其中一块的Survivor中存活的对象一起copy到另一块Survivor中。这样浪费的空间只有10%.但是我们不能保证每次存活的对象都小于10%,当存活的对象大于10时，会依赖其他内存分配担保。
这种算法的缺点：

1. 对象的存活率不能太高，否则会增加复制操作的次数。 (所以老年代一般不能使用这种算法)
2. 需要额外的空间进行担保。

#### 标记 - 整理算法

标记和第一种算法一样，然后将所有存活的对象，向一端移动，然后清理掉端边界以外的内存。

#### 分代收集算法

根据对象的存活周期，java堆对象分为新生代和老年代，然后根据不同的代，使用不同的算法

新生代： 复制算法
老年代：标记-清除算法 或者 标记-整理算法


## 垃圾回收器


#### Serial收集器

他是“单线程”工作的，在它执行的时候，其他的所有工作线程都的停止。就好比你妈妈在给你收拾房间的时候，你的老老实实的待在椅子上，要不你妈妈一边收拾，你一边扔垃圾，那什么时候才能收拾完呢。

#### ParNew收集器

他是Serial的多线程版本

#### Parallel Scaenge 收集器


#### Serial Old收集器

Serial的后年代收集器版本

#### CMS收集器
#### G1收集器


## 内存分配和回收策略



#### 对象优先在Eden分配


#### 大对象直接进入老年代

大对象是指：大量连续内存空间的Java对象，虚拟机提供了一个参数-XX: PretenureSizeThreshold,令大于这个设置的对象,直接分配到老年代，这样防止在新生代频发的gc拷贝。

#### 长期存活的对象进入老年代

虚拟机是怎么区分哪些对象应该放在新生代，哪些放在老年代中呢？是通过age计数器，出生在eden，每次Minor gc,然后对象仍然存活，并且能被拷贝到survivor,则age加1，如果age超过15(默认，可设置）,对象则被放到老年代。

#### 动态对象年龄判定

虚拟机并不总是要求年龄达到MaxTenuringThreshold才能晋升到老年代。如果在Survivor中相同年龄所有对象的总和达到Survivor空间的一半，则这些对象也会晋升为老年代。


#### 空间分配担保

新生代进行回收使用的是复制算法，如果存活的对象的大小大于Survivor的大小，那么超出的部分对象将直接进入老年代。


## Full gc和 Minor gc的区别

Full gc是对整个堆进行回收， Minor gc是只对新生代进行回收






































































