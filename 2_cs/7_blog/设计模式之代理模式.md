
## 提纲

1. 静态代理

2. 动态代理的java实现

3. Retrofit 动态代理模式

4. Java原生动态代理的实现

https://www.cnblogs.com/huhx/p/dynamicTheoryAdvance.html
https://blog.csdn.net/mhmyqn/article/details/48474815
https://my.oschina.net/u/2474629/blog/703611
https://www.jianshu.com/p/d5d9215bf8ad
https://www.cnblogs.com/liuyun1995/p/8144706.html
https://www.cnblogs.com/liuyun1995/p/8144628.html
https://www.cnblogs.com/liuyun1995/p/8157098.html
https://www.cnblogs.com/liuyun1995/p/8144676.html


# 从炒股说起

今天学习一下设计模式中的代理模式，但是开始之前先说一下最近的股市，最近的股市很疯狂，时常1秒钟就能错个一个亿。但是上班时间，又没法花太多的时间关注股市。于是决定找个操盘手，让他替我炒股（以上情节重属虚构，怎么可能把股票账户给别人，露富了咋办～）。于是想到了设计模式中的代理模式，下面就看看它的实现。

# 静态代理


先定义一个投资者

```
public interface IInvestor {

    /**
     * 登录股票账户
     * @param user
     * @param password
     */
    void login(String user, String password);

    /**
     * 买股票
     */
    void buyStock();

    /**
     * 卖股票
     */
    void sellStock();
}



```


```

public class Investor implements IInvestor {

    private String mName;

    public Investor(String name){
        this.mName = name;
    }

    @Override
    public void login(String user, String password) {
        System.out.println(this.mName + "登录成功！");
    }

    @Override
    public void buyStock() {
        System.out.println(this.mName + "在买股票！");
    }

    @Override
    public void sellStock() {
        System.out.println(this.mName + "在卖股票！");
    }
}


```

操盘手


```
public class InvestorProxy implements IInvestor {


    private IInvestor mInvestor;

    public InvestorProxy(IInvestor investor){
        this.mInvestor = investor;
    }

    @Override
    public void login(String user, String password) {
        mInvestor.login(user, password);
    }

    @Override
    public void buyStock() {
        mInvestor.buyStock();
        fee();
    }

    @Override
    public void sellStock() {
        mInvestor.sellStock();
        fee();
    }

    public void fee(){
        System.out.println("买卖股票费用： 100元");
    }
}
```

看一下场景类

```

public class InvestorProxy implements IInvestor {


    private IInvestor mInvestor;

    public InvestorProxy(IInvestor investor){
        this.mInvestor = investor;
    }

    @Override
    public void login(String user, String password) {
        mInvestor.login(user, password);
    }

    @Override
    public void buyStock() {
        mInvestor.buyStock();
        fee();
    }

    @Override
    public void sellStock() {
        mInvestor.sellStock();
        fee();
    }

    public void fee(){
        System.out.println("买卖股票费用： 100元");
    }
}


```

## 静态代理通用代码实现

```
public interface Subject {

    void doSomething();
}

```


```
public class RealSubject implements Subject {
    @Override
    public void doSomething() {

    }
}


```


```
public class Proxy implements Subject {


    /** 要代理哪个实现类 */
    private Subject subject = null;

    public Proxy(Subject subject){
        this.subject = subject;
    }
    @Override
    public void doSomething() {
        before();
        subject.doSomething();
        after();
    }

    /**
     * 预处理
     */
    private void before(){
    }

    /**
     * 善后处理
     */
    private void after(){
    }
}

```







# 动态代理

```
public class InvestorIH implements InvocationHandler {

    /** 被代理者 */
    private Class mCls = null;
    /** 被代理的实例 */
    private Object mObj = null;

    public InvestorIH(Object obj){
        this.mObj = obj;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object result = method.invoke(this.mObj, args);
        return result;
    }
}
```
动态代理是根据被代理的接口生成所有的方法，也就是说给定一个接口,动态代理会宣称“我已经实现该接口下的所有方法了”。动态代理已经实现了所有的接口方法，但是默认是没有逻辑的，返回值都是空的，但是没有任何逻辑该怎么办，通过InvocationHandler，所有的方法都由InvocationHandler接管处理。


# Retrofit动态代理
 上面讲了动态代理的基本的用法和优缺点，为了加深理解，下面介绍一个他在Retorfit中的一个经典使用。

Retrofit基本使用
```
Retrofit retrofit = new Retrofit.Builder()
              .baseUrl("https://api.github.com")
              .addConverterFactory(GsonConverterFactory.create())
              .build();
      GitHubService service = retrofit.create(GitHubService.class);

      Call<List<User>> repos = service.groupList(123, "123");
      repos.enqueue(new Callback<List<User>>() {
          @Override
          public void onResponse(Call<List<User>> call, Response<List<User>> response) {

          }

          @Override
          public void onFailure(Call<List<User>> call, Throwable t) {

          }
      });


```

retrofit.create 方法就是创建一个代理，让代理去进行真正的网络请求。

所以我们主要看看下面的代码

```

@SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
 public <T> T create(final Class<T> service) {
   Utils.validateServiceInterface(service);
   if (validateEagerly) {
     eagerlyValidateMethods(service);
   }
   return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
       new InvocationHandler() {
         private final Platform platform = Platform.get();
         private final Object[] emptyArgs = new Object[0];

         @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)
             throws Throwable {
           // If the method is a method from Object then defer to normal invocation.
           if (method.getDeclaringClass() == Object.class) {
             return method.invoke(this, args);
           }
           if (platform.isDefaultMethod(method)) {
             return platform.invokeDefaultMethod(method, service, proxy, args);
           }
           return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);
         }
       });
 }

```
可以看到它也是创建了一个InvocationHandler内部类，所有的逻辑都在invoke方法里。invoke方法中最重要的是最后一句

```

return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);

```

看看loadServiceMethod(method)和invoke方法中做了什么


loadServiceMethod方法代码

```

ServiceMethod<?> loadServiceMethod(Method method) {
    ServiceMethod<?> result = serviceMethodCache.get(method);
    if (result != null) return result;

    synchronized (serviceMethodCache) {
      result = serviceMethodCache.get(method);
      if (result == null) {
        result = ServiceMethod.parseAnnotations(this, method);
        serviceMethodCache.put(method, result);
      }
    }
    return result;
  }


```
这个方法主要的是作用是，把我们在GitHubService中定义的请求方法的注解解析出来，为我们调用OkHttp请求做准备。那么真正的请求就到了ServiceMethod的invoke方法中，看看它的实现

```
@Override ReturnT invoke(Object[] args) {
   return callAdapter.adapt(
       new OkHttpCall<>(requestFactory, args, callFactory, responseConverter));
 }

```

现在回想一下，Retrofit为什么要这样设计。我们调用请求方法时，其实并不关心OkHttp是怎么调用的，我们只要结果。但是每个请求方法执行都流程都是差不多的，都需要请求参数的构建，一大堆的请求配置。这些繁琐的操作都让代理类去完成了，这就是Retrofit采用动态代理的初衷吧。这只是我个人的理解。


# JDK中动态代理的原理

 在上面的内容中，我们了解了动态代理的基本使用方式和使用场景，并且大致看了一下Retrofit中关于动态代理的实现。但是，动态代理中，有个地方我们使用起来是不放心的，java做了个黑箱操作。

那就是动态代理中，代理类的生成。java只告诉我们你调用 Proxy中的

```
public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)

```
方法就可以了，但是，他里面这个代理类是怎么生成的，我们很好奇，下面就看看它的实现。


这个方法需要传入3个参数，先看看他们的作用

- loader
一个类加载器
- interfaces

一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口

- h
上文中多次提到的handler

返回一个代理对象

直接开注释吧

```

@CallerSensitive
   public static Object newProxyInstance(ClassLoader loader,
                                         Class<?>[] interfaces,
                                         InvocationHandler h)
       throws IllegalArgumentException
   {

       Objects.requireNonNull(h);

       //克隆要被代理的接口
       final Class<?>[] intfs = interfaces.clone();
       final SecurityManager sm = System.getSecurityManager();
       if (sm != null) {
           checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
       }

       /*
        * Look up or generate the designated proxy class.
        */
        //查找或者生成特定的代理类 class
       Class<?> cl = getProxyClass0(loader, intfs);

       /*
        * Invoke its constructor with the designated invocation handler.
        */
       try {
           if (sm != null) {
               checkNewProxyPermission(Reflection.getCallerClass(), cl);
           }
           //获取参数类型是InvocationHandler.class的代理类构造器
           final Constructor<?> cons = cl.getConstructor(constructorParams);
           final InvocationHandler ih = h;
           if (!Modifier.isPublic(cl.getModifiers())) {
               AccessController.doPrivileged(new PrivilegedAction<Void>() {
                   public Void run() {
                       cons.setAccessible(true);
                       return null;
                   }
               });
           }
            //传入InvocationHandler实例去构造一个代理类的实例
           return cons.newInstance(new Object[]{h});
       } catch (IllegalAccessException|InstantiationException e) {
           throw new InternalError(e.toString(), e);
       } catch (InvocationTargetException e) {
           Throwable t = e.getCause();
           if (t instanceof RuntimeException) {
               throw (RuntimeException) t;
           } else {
               throw new InternalError(t.toString(), t);
           }
       } catch (NoSuchMethodException e) {
           throw new InternalError(e.toString(), e);
       }
   }


```
所以获取代理类的实例，重点到了下面的这行代码中

```

//查找或者生成特定的代理类 class
Class<?> cl = getProxyClass0(loader, intfs);

```

看看getProxy方法的实现

```
/**
   * Generate a proxy class.  Must call the checkProxyAccess method
   * to perform permission checks before calling this.
   */
  private static Class<?> getProxyClass0(ClassLoader loader,
                                         Class<?>... interfaces) {
      if (interfaces.length > 65535) {
          throw new IllegalArgumentException("interface limit exceeded");
      }

      // If the proxy class defined by the given loader implementing
      // the given interfaces exists, this will simply return the cached copy;
      // otherwise, it will create the proxy class via the ProxyClassFactory

      //如果缓存中有，则使用缓存，否则通过ProxyClassFactory创建
      return proxyClassCache.get(loader, interfaces);
  }


```

获取代理Class其实通过proxyClassCache获取的，关于从缓存中获取这块的逻辑我们先略过。通过注释我们知道
这个真正proxy class 是通过ProxyClassFactory类生成的，它主要的逻辑在apply方法中，下面就看看它的逻辑。


```

@Override
       public Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {

           Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);
           for (Class<?> intf : interfaces) {

              //整个for循环主要做一样验证判断
               /*
                * Verify that the class loader resolves the name of this
                * interface to the same Class object.
                */
               Class<?> interfaceClass = null;
               try {
                   interfaceClass = Class.forName(intf.getName(), false, loader);
               } catch (ClassNotFoundException e) {
               }
               if (interfaceClass != intf) {
                   throw new IllegalArgumentException(
                       intf + " is not visible from class loader");
               }
               /*
                * Verify that the Class object actually represents an
                * interface.
                */
               if (!interfaceClass.isInterface()) {
                   throw new IllegalArgumentException(
                       interfaceClass.getName() + " is not an interface");
               }
               /*
                * Verify that this interface is not a duplicate.
                */
               if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {
                   throw new IllegalArgumentException(
                       "repeated interface: " + interfaceClass.getName());
               }
           }

           String proxyPkg = null;     // package to define proxy class in
           int accessFlags = Modifier.PUBLIC | Modifier.FINAL;

           /*
            * Record the package of a non-public proxy interface so that the
            * proxy class will be defined in the same package.  Verify that
            * all non-public proxy interfaces are in the same package.
            */
           for (Class<?> intf : interfaces) {
               int flags = intf.getModifiers();
               if (!Modifier.isPublic(flags)) {
                   accessFlags = Modifier.FINAL;
                   String name = intf.getName();
                   int n = name.lastIndexOf('.');
                   String pkg = ((n == -1) ? "" : name.substring(0, n + 1));
                   if (proxyPkg == null) {
                       proxyPkg = pkg;
                   } else if (!pkg.equals(proxyPkg)) {
                       throw new IllegalArgumentException(
                           "non-public interfaces from different packages");
                   }
               }
           }

           if (proxyPkg == null) {
               // if no non-public proxy interfaces, use com.sun.proxy package
               proxyPkg = ReflectUtil.PROXY_PACKAGE + ".";
           }

           /*
            * Choose a name for the proxy class to generate.
            */
           long num = nextUniqueNumber.getAndIncrement();
           String proxyName = proxyPkg + proxyClassNamePrefix + num;

           /*
            * Generate the specified proxy class.
            */
          //生成特定的.class文件
           byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
               proxyName, interfaces, accessFlags);
           try {
               return defineClass0(loader, proxyName,
                                   proxyClassFile, 0, proxyClassFile.length);
           } catch (ClassFormatError e) {
               /*
                * A ClassFormatError here means that (barring bugs in the
                * proxy class generation code) there was some other
                * invalid aspect of the arguments supplied to the proxy
                * class creation (such as virtual machine limitations
                * exceeded).
                */
               throw new IllegalArgumentException(e.toString());
           }
       }
   }


```
