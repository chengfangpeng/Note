## 概述
RecyclerView中有许多神奇的特性，比如局部刷新，它不仅可以针对某个item进行刷新，也可以针对item中的某些数据进行刷新。这对我们页面的页面渲染带来了很大的提升。那么RecyclerView是怎么通过对新旧数据的对比来做到局部刷新的？更进一步，对比新旧数据的这个Diff算法又是什么的样子的。下面将会从这两个部分来展开讨论。

## RecyclerView的局部刷新



## Diff算法
在上面使用RecyclerView做局部刷新的时候，使用了一个DiffUtil工具类。那么这个工具类是基于什么样的算法实现的？
要讲明白这个问题需先介绍一些概念

#### 概念解释

- Myers Diff算法  

 DiffUtil这个工具类使用的Diff算法来自于Eugene W. Myers在1986年发表的一篇算法[论文](http://xmailserver.org/diff2.pdf)


- 有向编辑图(Edit graph)

 算法依赖于新旧数据（定义为A和B构成的有向编辑图, 图中A为X轴, B为Y轴, 假定A和B的长度分别为M, N, 每个坐标代表了各自字符串中的一个字符. 在图中沿X轴前进代表删除A中的字符, 沿Y轴前进代表插入B中的字符. 在横坐标于纵坐标字符相同的地方, 会有一条对角线连接左上与右下两点, 表示不需任何编辑, 等价于路径长度为0. 算法的目标, 就是寻找到一个从坐标(0, 0)到(M, N)的最短路径

- Trace

  路径中斜线边的“匹配点”组成的序列,长度为L

- 最短编辑脚本(SES Shortest Edit Script)

  仅包含两种操作：删除和添加。从(0, 0)到(M, N)删除了N-L个字符，添加了M-L个字符，对于每一个trace,有一个对应的编辑脚本D = M + N - 2L

- 最长公共子序列(LCS Longest Common Subsequence)

LCS是两个字符串中去掉一些字符后，所产生的共有的最长的字符串序列，注意，这与最长公共字符串是不同的，后者是必须连续的。寻找LCS其实就是寻找Trace的最大长度。

> 寻找LCS的问题与寻找一条从(0, 0)到(M, N)同时有最多数量的斜边是等价的

> 寻找SES与寻找一条从(0, 0)到(M, N)同时有最少数量的非斜边的问题是等价的


- snake(蛇形线)

 一条snake表示横(竖)方向移动一步后接着尽可能多的斜边方向的移动，组成的线


 - 斜线k

  k = x - y定义的一条直线，也就是k相同的点组成的一条直线。k线之间是相互平行的斜线。


 - D-path

 移动D步后的点的连线，D的大小是不包含斜线的数量的


#### 两个引理
 - 引理1
  *一个D-path的终点一定在斜线k上， 其中 k ∈ { -D, -D + 2, ... D -2 , D}* 。证明可以使用数学归纳法，详细证明见[论文](http://xmailserver.org/diff2.pdf)

 - 引理2

 0-path的最远到达点为(x, x)，其中x ∈ min(z - 1 || az ≠ bz or z > M 或 z > N)。D-path的最远到达点在k线上，可以被分解为在k-1 线上的(D-1)-path，跟着一条横向边，接着一条越长越好的斜边 和 在k+1 线上的(D-1)-path，跟着一条竖向边，接着一条越长越好的斜边
 这条引理是Snake的理论依据
